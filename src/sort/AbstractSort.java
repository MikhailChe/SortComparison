package sort;

import java.util.Vector;

public abstract class AbstractSort implements Runnable {

	public AbstractSort(VecaRect vect) {
		/*
		 * Конструктор сортировочного класса BubbleSort В качестве
		 * параметра принимает массив, который
		 * нужно отсортировать
		 */
		this.veca = vect;
		this.v = vect.Numbers;
		/*
		 * Присваиваем переменной veca переданный массив;
		 * 
		 * Присваиваем переменной v массив из значений;
		 */
	}

	/*
	 * Переменная для хранения указателя на Main
	 */
	public VecaRect veca;
	/*
	 * Переменная для хранения объекта класса VecaRect
	 */
	public Vector<Integer> v;

	@Override
	public void run() {
		/*
		 * Для запуска нового потока нужна функция run().
		 */
		SetName();
		/*
		 * Сначала задаем имя сортировки.
		 */
		veca.clearTime();
		/*
		 * Очищаем время, затраченное на сортировку в прошлый раз. Если такого
		 * нет, то ничего не происходит
		 */
		double thetime = System.currentTimeMillis();
		/*
		 * Записываем текущее время в переменную thetime
		 */
		Sort(v);
		/*
		 * Запускаем сортировку
		 */
		veca.setTime("" + (System.currentTimeMillis() - thetime) / 1000);
		/*
		 * По окончании сортировки устанавливаем потраченое время в
		 * соответствующее значение
		 */
		veca.DeselectAll();
		/*
		 * Снимаем выделение со всех элементов
		 */
		Main.redrawG();
		/*
		 * Перерисовываем графику
		 */
		// t.cancel();
		/*
		 * Отменяем таймер
		 */
	}

	abstract void SetName();

	public synchronized void Swap(Vector<Integer> vect, int index1, int index2) {
		/*
		 * Swap - функция, которая меняет элементы местами
		 */
		if (Main.stopAll == true) {
			/*
			 * Завершение, если нужно выйти из сортировки
			 */
			return;
		}
		if (vect.size() > 200) {
			/*
			 * Если количество элементов в массиве болше 200, тогда показывать
			 * анимацию бессмысленно и мы вызываем функцию swap объекта класса
			 * VecaRect с третьим параметром false, который отменяет анимацию
			 */
			veca.Swap(index1, index2, false);
		} else {
			/*
			 * Иначе с анимацией
			 */
			veca.Swap(index1, index2, true);
		}
	}

	public abstract void Sort(Vector<Integer> vect);

	/*
	 * Таким образом структура сортировочного класса является очень гибкой. Для
	 * того чтобы добавить в программу новый тип сортировки достаточно либо
	 * скопировать текущий код (либо унаследовать любой из сортировочных классов
	 * и поменять только функцию Sort и значение переменной SortName - Название
	 * сортировки, которое будет отображаться в программе
	 * 
	 * В Sort нужно вписать свой алгоритм сортировки, используя, если нужно,
	 * функцию Swap, которая принимает всего два параметра - индексы первого и
	 * второго элементов.
	 * 
	 * Так же нельзя забывать, что если графически какой-то элемент нужно
	 * выделить, то достаточно просто указать его индекс в функции SelectElement
	 * 
	 * В нужные места также нужно вставлять паузы функцией
	 * Main.pause(Main.PAUSETIME.getValue());
	 * 
	 * В связи с тем, что структура у всех сортировочных классов одинаковая,
	 * опиисание их структур будет излишним
	 */
}
